# JLS

[协议PDF](https://github.com/JimmyHuang454/JLS/blob/master/pdf/thuthesis-example.pdf)

# 小白总结
1. 无需证书，伪装成任何网站
2. 1-RTT ，防止任何重放攻击
3. 不需要每次都跟伪装站交互
4. 很安全；不能被识别出来，无视主动探测

# 1. 对已知明文做加密
讨论这个是因为 JLS 是使用 AES-GCM 加密和认证的，有一个攻击方式叫：已知明文攻击，就是已知原文，可能会降低攻击难度。一个比较典型的例子是 SS，目前 CFB 已经被广泛认为是不安全的，可以用 AES-GCM 等可以抵抗已知明文攻击的加密算法，但有一个前提，就是要求 IV（随机数，也称为 nonce）具有随机性，这个随机性包括：足够随机和唯一性，比较符合这个要求的是 UUID 生成算法。简单来说，IV 越长随随机，AES-GCM 就越安全。而且这个 IV 是可以选择公布或私密。

JLS 选择的方案是 密码和 IV 都不公布，选择的 IV 长度是 64 字节，而且是固定用户输入的 IV。那如何保证随机性？可以从 JLS 文档中看出：第一次生成 Client Hello 时，IV 是包含了 Client Hello，然后做一次哈希，这个 Client Hello 里面包含了随机的 Session ID，而且可以防止篡改 Client Hello，这种做法是参考了 TLS 的，TLS 也是要求不能篡改 Hello。

然后到 Application Data，IV 是如何保证随机的？我们需要知道的一点，GCM 的 IV 是允许仅保留唯一性，因为 GCM 内部会再对他做一次"随机化"，也就是说，我们可以每加密一次，就对 IV 自增 1，可用于下次加密。JLS 在加密 Application Data 时，还会对 IV 再做一次哈希，使 IV 看起来更加的"随机"。

<!-- 需要注意的是 TLS 有专门的 AEAD 规定，我们为了方便，选取了以上方案。 -->

# 2. 有效JLS认证
如何判断收到的 Client Hello 或者 Server Hello 是属于 JLS？因为是使用 AES-GCM 来认证的，那么就离不开 IV 的随机性。JLS 选择的方案是先生成一个随机数 N，然后用 AES-GCM 对其加密，属于从源头让已知明文攻击不成立，或者一种等价的说法：这个 N 就是加入的随机数。因为密码和 IV 都是固定的，所以仅有效的客户端/服务端能够正确解密，这时我们就可以判断是否是有效 JLS。

目前这个 N，JLS 选择的长度是 16 字节，我觉得安全性还不够。考虑以后会修改这个。

# 3. 前向安全性
前向安全性是 TLS1.3 新加的内容。他通过 DH 密钥生成算法，得出本次对话的仅双方知道一个共享密钥，这样可以确保本次的加密数据与之前的加密所用的密钥都不一致。JLS 选择是 x25519，因为比较多的 TLS 都会选择这一种算法。

JLS 要求 Client 和 Server 都必须能正确地处理 x25519，行为跟 TLS1.3 一致，得出共享密钥后，按照 TLS 的时序发送一些特征数据（JLS 文档中有规定）。并且还要求共享密钥也要参与运算。事实上的 TLS 是三个数组成最终密钥：共享密钥 + 来自 Client 的随机数 + 来自 Server 的随机数。所以我们能比较好地确保本次对话是唯一的。

# 4. 防止重放攻击
x25519 确保本次对话都是唯一，但不能确保数据不被重放。TLS 的 Application Data 最大长度是 2^14，我觉得这是 TLS 的诟病之一。但对每个 Packet 编号，把这个编号也使他参与到加密运算中，可以很好地防止重放攻击。TLS 是这样做的。JLS 的处理方式跟 TLS 差不多，显然，如果这里我们用时间戳来防止 Packet 重放，是很低效的。

# 5. Application Data 加密与解密

上文已讲，在保证 IV 随机的前提下，JLS 对 Application Data 加密用的是 AES-GCM；有人可能会想：使用非对称加密，即使在 Client 配置泄露的情况下，也可以做到向 Server 发数据而不被破解。

首先，TLS1.2 获得加密密钥的方式很有趣，用非对称加密获得对称加密的密钥。因为非对称对比对称从速度上看差不是一点半点。或许我们可以选取一种更好的方法，JLS 在 Hello 时，直接使用非对称而不是 GCM，Client 发送仅能 Server 非对称解密的随机数。这种方法可以考虑，但是在 Hello 中需要找出更多的位置来存储。

# 6. Server 伪装

假设 Client 是来自于谷歌浏览器的 HTTPS 数据，这种情况怎么处理呢？JLS 是有伪装站的，这个伪装站的意思就是判断进入 Client，不是有效 Client 的时候，把收到的数据原封不动通过 TCP 转发到伪装站，原理跟 Trojan 一致。

有人说，抄袭了他的“缓存模式”？我并不理解这个“缓存模式”指的是什么意思。我姑且错误地理解为：Server 不想解析 TLS 数据，每次收到的 Client Hello 都要发送到伪装站，然后截获返回的 Server Hello，这样会导致每次请求是都要先请求伪装站，如果它不返回 Server Hello 就无法正常建立连接。有人就想：我可以预想请求很多的 Server Hello，先让他挂在那里，等需要用了，再取出来。这跟 DDOS 攻击有什么区别呢？我觉得是很容易会被伪装站封杀 IP。

当然啦，JLS 不会做这种事情，他会完整地解析 Client Hello，做着跟 TLS Server 一样的事情。不是有效 Client 才转发，不转发时是名副其实的简易 TLS，转发时也是真正的 TLS。

# 7. Client 伪装
假设本机通过 JLS 获得 Server Hello 是伪装站真实的 Server Hello，这种情况怎么处理呢？**JLS 就是一种伪 TLS**，要求实现跟 TLS 一样的功能，在这种情况下，获得的 Server Hello 是可以识别出来是否是有效 Server，JLS 要求 Client 必须正确地解析 TLS Server Hello，完成 TLS1.3 应该做的事情，然后发送一个 HTTP 请求，最后关闭 TCP。

# 8. Server 证书
JLS 不需要偷证书！返回证书内容可以随意！

TLS1.3 除了 Hello，其他数据都是加密的，也就是说 Server 发送的证书也就仅 Client 可以解密。如果是有效 Client，JLS Server 此时可以发送随意内容给 Client（当然会用 Application Data 包起来）。 有些人可能会问：比如我的伪装站是 apple.com，我访问 apple.com 返回的证书长度是 a，通过你的服务器访问获得的证书长度是 b，所以攻击者可以判定你这个不是苹果公司的服务器。

首先要注意一些前提：

1. 我可没告诉你 我的服务器是苹果公司的，虽然他的页面长得跟苹果的一模一样，而且你自己去获取的证书也是苹果公司的。

2. 服务器是被允许返回不同的 Server 证书，你又怎么知道服务器给你的证书和给我的证书是一致的呢？

通过这些前提，我们可以得知，攻击者需要收集很多证书，虽然你可以通过证书知道服务器“可能”属于苹果公司，但就是需要你去收集。

JLS 还设定了可以自定义证书长度选项；目前这种大规模收集证书的模式还未出现，等到出现的那一天，我们可以用软件定期去探测伪装站的证书长度。

# 9. PSK 细节处理

有用户反馈，如果伪装站是支持 PSK，我们每次的请求都不支持 PSK，也就是 0-RTT。首先，这的确可能会成为一种特征，但 PSK 是 Client 的可选功能，不使用 PSK 也是被 TLS 允许的。我们可以考虑伪装 Client Hello 时，加入一些 PSK 的字段，可以解决这个问题。
